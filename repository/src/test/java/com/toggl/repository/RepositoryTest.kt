package com.toggl.repository

import com.toggl.database.dao.ProjectDao
import com.toggl.database.dao.TimeEntryDao
import com.toggl.database.dao.WorkspaceDao
import com.toggl.environment.services.time.TimeService
import com.toggl.models.domain.TimeEntry
import com.toggl.models.domain.Workspace
import com.toggl.models.domain.WorkspaceFeature
import com.toggl.repository.interfaces.StartTimeEntryResult
import io.kotlintest.TestCase
import io.kotlintest.shouldBe
import io.kotlintest.specs.StringSpec
import io.mockk.called
import io.mockk.clearMocks
import io.mockk.coEvery
import io.mockk.coVerify
import io.mockk.every
import io.mockk.mockk
import io.mockk.spyk
import io.mockk.verify
import org.threeten.bp.Duration
import org.threeten.bp.OffsetDateTime

class RepositoryTest : StringSpec() {
    private val projectDao = mockk<ProjectDao>()
    private val timeEntryDao = mockk<TimeEntryDao>()
    private val workspaceDao = mockk<WorkspaceDao>()
    private val timeService = mockk<TimeService>()
    private var repository = Repository(projectDao, timeEntryDao, workspaceDao, timeService)

    override fun beforeTest(testCase: TestCase) {
        super.beforeTest(testCase)
        clearMocks(timeEntryDao, workspaceDao, timeService)
    }

    init {
        "loadTimeEntries calls getAll on the DAO" {
            every { timeEntryDao.getAll() } returns listOf()

            val loaded = repository.loadTimeEntries()

            verify(exactly = 1) { timeEntryDao.getAll() }
            verify {
                workspaceDao wasNot called
                timeService wasNot called
            }
            loaded shouldBe listOf()
        }

        "loadWorkspaces calls getAll on the DAO and returns elements if there are any" {
            val someWorkspace = Workspace(
                123,
                "Workspace name",
                features = listOf()
            )
            every { workspaceDao.getAll() } returns listOf(someWorkspace)

            val loaded = repository.loadWorkspaces()

            verify(exactly = 1) { workspaceDao.getAll() }
            verify {
                timeEntryDao wasNot called
                timeService wasNot called
            }
            loaded shouldBe listOf(someWorkspace)
        }

        "loadWorkspaces calls getAll on the DAO and returns an auto-generated workspace if there aren't any workspaces returned by DAO" {
            every { workspaceDao.getAll() } returns listOf()
            every { workspaceDao.insert(any()) } returns 1337
            val autoGeneratedWorkspace = Workspace(
                0,
                "Auto created workspace",
                listOf(
                    WorkspaceFeature.Pro
                )
            )

            val loaded = repository.loadWorkspaces()

            verify(exactly = 1) { workspaceDao.insert(autoGeneratedWorkspace) }
            verify {
                timeEntryDao wasNot called
                timeService wasNot called
            }
            loaded shouldBe listOf(autoGeneratedWorkspace.copy(id = 1337))
        }

        "stopRunningTimeEntry updates all running time entries and returns the first one" {
            val timeEntryOneStartTime = OffsetDateTime.parse("2019-07-17T17:15:17+01:00")
            val timeEntryRunningOne =
                TimeEntry(
                    1,
                    "one running",
                    timeEntryOneStartTime,
                    null,
                    false,
                    0,
                    0,
                    0,
                    false
                )
            val timeEntryTwoStartTime = OffsetDateTime.parse("2019-07-17T12:17:17+01:00")
            val timeEntryRunningTwo = timeEntryRunningOne.copy(
                id = 3,
                startTime = timeEntryTwoStartTime
            )
            val nowTime = OffsetDateTime.parse("2019-07-17T17:17:17+01:00")
            every { timeService.now() } returns nowTime
            every { timeEntryDao.getAllRunning() } returns listOf(
                timeEntryRunningOne,
                timeEntryRunningTwo
            )
            every { timeEntryDao.updateAll(any()) } returns mockk()

            val result = repository.stopRunningTimeEntry()

            verify(exactly = 1) {
                timeEntryDao.updateAll(
                    listOf(
                        timeEntryRunningOne.copy(
                            duration = Duration.between(
                                timeEntryOneStartTime,
                                nowTime
                            )
                        ),
                        timeEntryRunningTwo.copy(
                            duration = Duration.between(
                                timeEntryTwoStartTime,
                                nowTime
                            )
                        )
                    )
                )
            }
            verify { workspaceDao wasNot called }
            result shouldBe timeEntryRunningOne.copy(
                duration = Duration.between(
                    timeEntryOneStartTime,
                    nowTime
                )
            )
        }

        "stopRunningTimeEntry doesn't update any time entries if none are running and doesn't return any time entries" {
            every { timeEntryDao.getAllRunning() } returns listOf()
            every { timeService.now() } returns mockk()
            every { timeEntryDao.updateAll(any()) } returns mockk()

            val result = repository.stopRunningTimeEntry()

            verify(exactly = 1) { timeEntryDao.updateAll(listOf()) }
            verify { workspaceDao wasNot called }
            result shouldBe null
        }

        "startTimeEntry stops currently running time entry and inserts a new one to DAO" {
            val nowTime = OffsetDateTime.parse("2019-07-17T17:17:17+01:00")
            val startedTimeEntry = TimeEntry(
                1337,
                "desc",
                nowTime,
                null,
                false,
                1,
                null,
                null,
                false
            )
            val stoppedTimeEntry = mockk<TimeEntry>()
            every { stoppedTimeEntry.startTime } returns nowTime.minusHours(1)
            every { stoppedTimeEntry.copy(allAny()) } returns stoppedTimeEntry
            coEvery { repository.stopRunningTimeEntry() } returns stoppedTimeEntry
            every { timeEntryDao.insert(any()) } returns 1337
            every { timeEntryDao.getOne(any()) } returns startedTimeEntry
            every { timeService.now() } returns nowTime
            every { timeEntryDao.getAllRunning() } returns listOf(stoppedTimeEntry)
            every { timeEntryDao.updateAll(any()) } returns mockk()
            val repositorySpy = spyk(repository)

            val result = repositorySpy.startTimeEntry(1, "desc")

            coVerify(exactly = 1) {
                repositorySpy.stopRunningTimeEntry()
            }
            verify(exactly = 1) {
                timeEntryDao.insert(startedTimeEntry.copy(id = 0))
                timeEntryDao.getOne(1337)
            }
            verify { workspaceDao wasNot called }
            result shouldBe StartTimeEntryResult(startedTimeEntry, stoppedTimeEntry)
        }

        "editTimeEntry updates the time entry and returns it" {
            val timeEntry = mockk<TimeEntry>()
            every { timeEntryDao.update(any()) } returns mockk()

            val result = repository.editTimeEntry(timeEntry)

            verify {
                workspaceDao wasNot called
                timeService wasNot called
            }
            result shouldBe timeEntry
        }

        "deleteTimeEntry sets isDeleted, updates the DAO and returns the updated entries" {
            val timeEntry = TimeEntry(
                1337,
                "desc",
                OffsetDateTime.MAX,
                null,
                false,
                1,
                null,
                null,
                false
            )
            every { timeEntryDao.update(any()) } returns mockk()

            val result =
                repository.deleteTimeEntry(timeEntry)

            verify(exactly = 1) {
                timeEntryDao.update(timeEntry.copy(isDeleted = true))
            }
            verify {
                workspaceDao wasNot called
                timeService wasNot called
            }
            result shouldBe timeEntry.copy(isDeleted = true)
        }
    }
}
